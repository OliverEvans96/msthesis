\chapter{NUMERICAL ANALYSIS}
\label{chap:model_analysis}

% TODO: Revise
In this chapter, both numerical implementations of the model are probed.
We begin by verifying that the methods are mistake-free by looking at convergence orders.
Then, the two methods are compared, to determine the conditions under which the asymptotic
approximation is valid.
Finally, results are compared to simpler kelp models.

\section{Verification and Validation of Computational Codes}
%TODO: Citations
As Roache explains, there are two aspects to confidence building for numerical codes, specifically those which solve PDEs:
verification deals with \textit{solving the equations right}, while validation deals with \textit{solving the right equations}.
Validation involves comparison with experimental evidence in order to determine that governing equations
accurately describe physical phenomenon, and that their solutions match observation.
Validation is an ongoing process.
As new experimental data becomes available, the equations can be solved in an attempt to replicate the observation.
Verification, however, is a purely mathematical exercise, and has nothing to do with the physical system being modeled.
It deals only with the agreement between an equation and its numerical solution produced by a particular implementation of an algorithm.
Unlike validation, verification is something to be started and finished.
If a set of parameters to the model can be chosen to exercise all terms in the equation, comparison between the numerical and exact solution is sufficient to demonstrate the correctness of a computational code, and the process need not be repeated unless the code is modified.

Due to lack of sufficient experimental data, rigorous validation of the model is left as future work.
However, verification of both the finite difference and numerical asymptotics algorithms is presented here.
There are two forms of verification.
The first is \textit{verification of codes}, where a whole implementation of an algorithm is tested, and the the difference between the numerical and analytical solutions is \textit{explicitly measured} at every point in the numerical solution.
The same calculation is repeated for several grid sizes, and it is checked that the convergence order as the grid spacing approaches zero matches the theoretical convergence order of the algorithm.
The explicit measurement of errors requires that the analytical solution be known, which is generally only possible for some unrealistic or uninteresting set of parameters.
If the analycal solution were available for the real, interesting case, then it would probably not have been necessary to implement a numerical solution in the first place.

Therefore, the second phase of verification is \textit{verification of calculations}, where a single specific calculation is performed, and the error is \textit{estimated} since it cannot be measured explicitly.
This is generally done by repeating the calculation for several grid sizes, as above, then using a technique called \textit{Richardson Extrapolation} to estimate the limiting solution as the grid spacing approaches zero.
This estimated limiting solution is then compared to the actual numerical solutions.
Error estimation for a specific calculation can be used to calculate error bars to display on a plot to represent discretization error in the solution.

\subsection{Method of Manufactured Solutions}

The most obvious way to obtain an analytical solution to compare to a numerical solution is by choosing a simple case where the PDE can be solved explicitly, perhaps through separation of variables or by reducing it to an ODE.
This is referred to as the Method of Exact Solutions.
However, such simple cases usually result in such a loss of generality as to make them nearly useless.
In order to verify that a code will work in an interesting case, every term in the equation must be exercised during the verification process.
An alternative process, the Method of Manufactured Solutions, retains arbitrary generality in the equations while making analytical solutions readily available.
Of course, there is a trade-off: the solutions are not physically realistic.
However, this is not an issue.
As stated previously, \textit{verification is a purely mathematical endeavor}.
Determining that a code solves an equation correctly is unrelated to physical realism.

Consider a differential equation
\begin{align}
  Du(\vec{x}) = \sigma(\vec{x}), \label{eqn:mms_de} \\
  u(\vec{x})=f(\vec{x}) \mbox{ for } \vec{x} \in \Sigma,
  \label{eqn:mms_bc}
\end{align}
where $D$ is a differential operator, $u$ is the solution, and $\sigma$ is a source term, $f$ is the boundary condition function, and $\Sigma$ is the set of boundary points at which the boundary condition is applied.
In general, $D$, $\sigma$, and $f$ are known, and solving for $u$ involves determining $D^{-1}$ and calculating $u = D^{-1}\sigma$ while satisfying \eqref{eqn:mms_bc}.

The Method of Manufactured Solutions reverses the normal procedure.
Here, $u$ is hand-picked at the outset, all parameters and coefficient functions in $D$ are chosen to be nonzero, and the source term $\sigma$ which produces the desired solution is calculated.
Similarly, the boundary condition is determined from the chosen solution.
In essence, rather than solving $u = D^{-1}\sigma$ subject to $u=f$, it suffices to compute $\sigma = Du$ and evaluate $f=u$ at the boundary.
Whereas \textit{inverting} a differential operator analytically is impossible for many equations and often requires ingenuity when it is, \textit{applying} onw is a plug-and-chug application of algebra and calculus.
Of course, it is necessary to construct $u$ and any coefficient functions in $D$ from simple, differentiable and integrable functions.

Also, $u$ must satisfy any constraints imposed by the algorithm such as hard-coded boundary conditions or requirements for positive coefficients.
Finally, the chosen functions should have small derivatives so that convergence can be achieved for reasonable grid sizes.
Since these functions may need to be fairly complicated in order to achieve full generality while meeting the necessary constraints, it is advisable to use a \textit{Computer Algebra System} (CAS) to perform the symbolic manipulations involved in computing $\sigma$.

\subsubsection{Application}
In order to verify the numerical implementations described in the previous chapters, it is necessary to first choose a manufactured solution $L(\vec{x}, \vec{\omega})$ to the radiative transfer equation, as well as coefficient functions for the absorption coefficient $a(\vec{x})$ and volume scattering function $\beta(\vec{\omega}\cdot{\vec{\omega'}}$.
For the particular implementations developed in this thesis, the following conditions must be met by the manufactured solution:
\begin{enumerate}
  \item Periodic in $x$ and $y$
  \item Positive absorption coefficient $a(\vec{x})$
  \item Position-independent surface downwelling boundary condition
  \item Zero upwelling radiance at the bottom boundary
  \item Properly normalized VSF $\beta$, as described in Section \ref{sec:iops}
\end{enumerate}

The chosen functions are
\begin{align}
  L(x, y, z, \theta, \phi) &= 
    \alpha \left(\sin{\left (\phi + \theta \right )} + 1\right) \nonumber\\
    &\quad\cdot \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \nonumber\\
    &\quad\cdot \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right),
  \label{eqn:mms_sol_expr}
\end{align}
\begin{equation}
  a(x, y, z) = \sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )} + \tanh{\left (- \gamma + z \right )} + 5
  \label{eqn:mms_abs_expr}
\end{equation}
\begin{equation}
  \beta(\Delta) = \frac{\Delta + 1}{4 \pi}
  \label{eqn:mms_vsf_expr}
\end{equation}
Using the python package Sympy, the boundary conditions and source function are calculated to be
% TODO: cite

\begin{align}
  &\quad\qquad f(\theta, \phi) = \alpha \left(- \gamma + 1\right) \left(\sin{\left (\phi + \theta \right )} + 1\right),
  \label{eqn:mms_vsf_expr} \\
  &\sigma(x, y, z, \theta, \phi) = \alpha \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \left(\sin{\left (\phi + \theta \right )} + 1\right) \nonumber\\
  %
  &\quad \cdot \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right) \left(b + \sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )} + \tanh{\left (- \gamma + z \right )} + 5\right) \nonumber\\
  %
  &\quad - b \Bigg[ \frac{\alpha \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \left(\frac{\sin{\left (\phi \right )} \sin{\left (\theta \right )}}{3} + \frac{\cos{\left (\phi \right )}}{3}\right) \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right)}{4 \pi} \nonumber\\
  %
  &\quad - \frac{\alpha \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right)}{4 \pi} \nonumber\\
  %
    &\quad \cdot \left(-\frac{\pi \sin{\left( \phi \right)}\sin{\left( \theta \right)}}{2} - \frac{\sin{\left (\phi \right )} \sin{\left (\theta \right )}}{3} - \frac{\cos{\left (\phi \right )}}{3}\right) \nonumber\\
  %
  &\quad - \frac{\alpha \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right)}{4 \pi} \nonumber\\
  %
    &\quad \cdot \left(\frac{\sin{\left( \phi \right)}\sin{\left( \theta \right)}}{3} - \frac{2 \pi \sin{\left (\phi \right )} \cos{\left (\theta \right )}}{3} + \frac{\cos{\left (\phi \right )}}{3} - 2 \pi\right) \nonumber\\
  %
  &\quad + \frac{\alpha \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right)}{4 \pi} \nonumber\\
  %
  &\quad \cdot \left(- \frac{\pi \sin{\left (\phi \right )} \sin{\left (\theta \right )}}{2} - \frac{\sin{\left(\phi\right)}\sin{\left(\theta\right)}}{3} + \frac{2 \pi \sin{\left (\phi \right )} \cos{\left (\theta \right )}}{3} - \frac{\cos{\left (\phi \right )}}{3} + 2 \pi\right) \Bigg] \nonumber\\
  %
  &\quad + 2 \pi z \left(\sin{\left (\phi + \theta \right )} + 1\right) \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right) \sin{\left (\phi \right )} \sin{\left (\theta \right )} \cos{\left (\frac{2 \pi y}{\alpha} \right )} \nonumber\\
  %
  &\quad + 2 \pi z \left(\sin{\left (\phi + \theta \right )} + 1\right) \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right) \sin{\left (\phi \right )} \cos{\left (\theta \right )} \cos{\left (\frac{2 \pi x}{\alpha} \right )} \nonumber\\
  %
  &\quad + \Bigg[\alpha \left(z \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) + 1\right) \nonumber\\
  &\quad \cdot \left(\frac{\left(- b - 1\right) \left(- \tanh^{2}{\left (\left(b + 1\right) \left(\gamma - z\right) \right )} + 1\right)}{\tanh{\left (\gamma \left(b + 1\right) \right )}} + 1\right) %\nonumber\\
  %
  \left(\sin{\left (\phi + \theta \right )} + 1\right) \nonumber\\
  %
  &\quad + \alpha \left(\sin{\left (\frac{2 \pi x}{\alpha} \right )} + \sin{\left (\frac{2 \pi y}{\alpha} \right )}\right) \left(\sin{\left (\phi + \theta \right )} + 1\right) \nonumber\\
  &\quad \cdot \left(- \gamma + z + \frac{\tanh{\left (\left(b + 1\right) \left(\gamma - z\right) \right )}}{\tanh{\left (\gamma \left(b + 1\right) \right )}}\right)\Bigg] \cos{\left (\phi \right )}
  \label{eqn:mms_source_expr}
\end{align}


% TODO: Revise
\subsubsection{Finite Difference}
A five dimensional $(x,y,x,\theta,\phi)$ resolution space is nontrivial to characterize.
For the sake of reducing dimensionality, we define generic spatial and angular resolutions
$n_s$ and $n_a$ such that $n_s=n_x=n_y$ and $n_a=n_\theta=n_\phi$.
Remaining is a three-dimensional resolution space, $(n_s,n_z,n_a)$.
Rather than perform calculations at every possible combination of resolutions in the space,
we choose a maximum resolution of $20 \times 20 \times 20$,
and hold two of the three resolutions at the maximum value while varying the third.
For example, Figure \ref{fig:gs_ns} compares $4 \times 20 \times 20$, $6 \times 20 \times 20$, $8 \times 20 \times 20$, etc.
The quantity that we compare is \textit{perceived irradiance}, which is different than the simple mean irradiance in each depth layer.
Rather, the average is weighted by the normalized spatial kelp distribution to determine the average irradiance experienced by the kelp population.
For more detail, see Section \ref{sec:perceived_irrad}

Note the different natures of convergence in each dimension.
In varying $n_s$, we see that the accuracy is very low for small $n_s$ values.
This is because in these cases, the horizontal grid cells are too large to capture any detail
about the kelp fronds near the bottom where they are very small.
The kelp is effectively not present in these layers, and therefore the perceived irradiance is zero.
After increasing the resolution past this minimum threshold, however, little improvement results
from increasing $n_s$ further, as seen in Figure \ref{fig:gs_ns}.
On the other hand, Figure \ref{fig:gs_nz} shows that increasing the vertical resolution
consistently improves the accuracy of the solution.
Figure \ref{fig:gs_na} shows that $n_a$ is somewhere between the two,
demonstrating clear improvement with increasing resolution, though the improvement is not uniform over depth.
Figure \ref{fig:gs_compare} shows the trend of increasing accuracy with increasing resolution in each dimension.

% TODO: Revise
\subsubsection{Numerical Asymptotics}

In this section, the four water cases from Table \ref{tab:petzold} are considered.
In each case, the full finite difference solution is calculated on an $18 \times 18 \times 18$ grid,
and asymptotic approximations are given, varying the number of terms used in the asymptotic series.
Perceived irradiances are shown, as well as errors from the finite difference solution.

In the first two cases, when the scattering coefficient is the same order or smaller as the absorption coefficient,
the asymptotic approximation converges to the finite difference solution.
However, in the very turbid water of the San Diego Harbor, the scattering coefficient is an order of magnitude higher
than the absorption coefficient, causing the asymptotic solution to quickly diverge.
In figure \ref{fig:asym_conv_compare}, average relative errors for the two converging cases are shown.
In both cases, the accuracy improves with more scattering events until it plateaus.
In the first case, 4 scattering events is sufficient, whereas in the second, the accuracy improves until 12 scattering events.

\subsection{Verification of Calculations}
\subsubsection{Richardson Extrapolation}
\subsubsection{Grid Convergence Index} %TODO: Leave out?
\subsubsection{Systematic Grid Convergence Study}

\section{Computational Resource Requirements}
\subsection{Finite Difference}
\subsubsection{Numerical Asymptotics}


\section{Rules of Thumb}
\subsection{What grid resolution to use?}
\subsubsection{Finite Difference}
\subsubsection{Numerical Asymptotics}

\subsection{Where is asymptotics valid}
\subsection{How many scattering events should be used?}

\section{Comparison to Other Light Models}


% TODO: Probably exclude
\section{Sensitivity Analysis}
In this section, we demonstrate the effect of varying some of the parameters of the model.
The 12-term asymptotic approximation is used.
In Figure \ref{fig:sens_analysis_a_water} and Figure \ref{fig:sens_analysis_b}, the solution
is shown to diverge when the ratio $b/a$ is too large, as in Section \ref{sec:asym_conv}.

\begin{figure}[H]
  \centering
  \vspace{-3em}
  \includegraphics[width=0.45\textwidth]{top-heavy_kelp}
  \includegraphics[width=0.45\textwidth]{top-heavy_irrad}
  \caption{\textit{top-heavy} kelp distribution (left) and no-scattering irradiance profile (right)}
\end{figure}

\begin{figure}[H]
  \centering
  \vspace{-3em}
  \includegraphics[width=0.45\textwidth]{bottom-heavy_kelp}
  \includegraphics[width=0.45\textwidth]{bottom-heavy_irrad}
  \caption{\textit{bottom-heavy} kelp distribution (left) and no-scattering irradiance profile (right)}
\end{figure}

\begin{figure}[H]
  \centering
  \vspace{-3em}
  \includegraphics[width=0.45\textwidth]{uniform_kelp}
  \includegraphics[width=0.45\textwidth]{uniform_irrad}
  \caption{\textit{uniform} kelp distribution (left) and no-scattering irradiance profile (right)}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{sens_analysis_kelp_profile}
  \caption{Several kelp profiles}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{sens_analysis_absorptance_kelp}
  \caption{Several values of kelp absorptance}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{sens_analysis_a_water}
  \caption{Several values of absorption coefficient of water}
  \label{fig:sens_analysis_a_water}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=4in]{sens_analysis_b}
  \caption{Several values of scattering coefficient}
  \label{fig:sens_analysis_b}
\end{figure}
